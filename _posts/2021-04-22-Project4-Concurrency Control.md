### Locks,Mutexes,Semaphores的区别

Locks：保护对共享对象的访问，即一个资源可以被多个线程共享。

Mutexes：如果不是特指某种互斥锁，一般指的是一个资源只能被一个线程占有。

Mutexes又分为Recursive Mutexes(可重入锁)、Reader/Writer Mutexes、Spinlocks。

Semaphores：不提了，就是PV操作。

### 处理原子性

![1619138986548](../image/1619138986548.png)

![1619138995885](../image/1619138995885.png)

### conflicting operations

![1619138953381](../image/1619138953381.png)

![1619139196436](../image/1619139196436.png)

### 两种串行化

![1619139766545](../image/1619139766545.png)

#### conflict serializability

![1619139249220](../image/1619139249220.png)

![1619139819386](../image/1619139819386.png)

#### view serializability

![1619139914391](../image/1619139914391.png)

![1619140229677](../image/1619140229677.png)

### 2PL

![1619140713416](../image/1619140713416.png)

![1619140803081](../image/1619140803081.png)

而严格2PL只有在最后才释放所有Locks

![1619142050590](../image/1619142050590.png)

![1619142068166](../image/1619142068166.png)

下面3图流说明Non-2PL、2PL、Strong 2PL之间的区别。

![1619142476999](../image/1619142476999.png)

![1619142488566](../image/1619142488566.png)

strong 2PL 释放锁都是在事务结束的时候。

![1619142499264](../image/1619142499264.png)

![1619143004299](../image/1619143004299.png)

![1619143200440](../image/1619143200440.png)

#### 2PL Deadlocks

![1619143517870](../image/1619143517870.png)

![1619143739250](../image/1619143739250.png)

#### Deadlock prevention

![1619144164702](../image/1619144164702.png)

![1619148762458](../image/1619148762458.png)

### Lock granularities

![1619148790982](../image/1619148790982.png)

![1619148802584](../image/1619148802584.png)

![1619148809547](../image/1619148809547.png)

### conclusion

![1619148969999](../image/1619148969999.png)

### optimistic concurrency control approaches（乐观和悲观）

![1619154865356](../image/1619154865356.png)

### Basic Timestamp Ordering (T/O) Protocol

![1619155015841](../image/1619155015841.png)

![1619156958551](../image/1619156958551.png)

![1619156997551](../image/1619156997551.png)

Thomas Write Rule提到我们可以忽略旧事务对于X的写操作，这是可以理解的，反正即使这个旧事务在正确的时间点对X进行写，写入的值也会被新事务的写所覆盖，最终结果依旧是X的值是新事务写入的值。

![1619158403409](../image/1619158403409.png)

### Optimistic Concurrency Control

……好像可串行化的快照隔离啊，有两种`基于过期的条件做决定`的方法，前向和后向（需要求证一下）。

![1619165116068](../image/1619165116068.png)

#### OCC 前向验证的三个要求

![1619164951339](../image/1619164951339.png)

![1619165983293](../image/1619165983293.png)

![1619166009816](../image/1619166009816.png)

下图中的读写集合冲突是对应与某一个时间点来说的，而不是针对整个事务持续时间来说的。

![1619166027249](../image/1619166027249.png)

在少量竞争的情况下，OCC比2PL表现好，因为不用锁。

### THE PHANTOM PROBLEM（幻读），2PL

目前我们只处理了read、update existing objects，但是面对不存在的object却没办法处理。（说真的一开始我都没看出来这是幻读，看了看示例才发现好像是幻读……）

![1619170422335](../image/1619170422335.png)

![1619170492469](../image/1619170492469.png)

![1619170660848](../image/1619170660848.png)

### Isolation Levels

![1619172780566](../image/1619172780566.png)

### MVCC

![1619175236443](../image/1619175236443.png)

