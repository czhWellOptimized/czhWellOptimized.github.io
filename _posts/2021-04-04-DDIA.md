---
layout: post
title: ddia
tags: [database]

---

第五章 数据复制

<script src="/assets/js/mermaid.min.js"></script>
<div class="mermaid">    
graph LR
    数据复制-->主从复制
    数据复制-->多主节点复制
    数据复制-->无主节点复制
	主从复制--> B(复制滞后问题)
	B-->C(读自己的写)
	B-->D(单调读)
	B-->E(前缀一致读)
	C-->F(事务)
	D-->F
	E-->F
	多主节点复制-->写冲突
	无主节点复制-->节点失效
	节点失效-->读修复
	节点失效-->反熵
	无主节点复制-->写冲突
	写冲突-->LWW
	写冲突-->Happens-before  
</div>

第六章 数据分区

<script src="/assets/js/mermaid.min.js"></script>
<div class="mermaid">    
graph LR
    数据分区-->分区办法
    数据分区-->二级索引分区
    数据分区-->分区再平衡
    分区办法-->基于关键字区间的分区
    分区办法-->哈希分区
    二级索引分区-->基于文档分区
    二级索引分区-->基于词条分区
    分区再平衡-->动态再平衡
    分区再平衡-->自动与手动再平衡
    动态再平衡-->固定数量分区
    动态再平衡-->动态分区
    动态再平衡-->按节点比例分区
</div>

第七章 事务


```html
<script src="/assets/js/mermaid.min.js"></script>
<div class="mermaid">    
graph LR
    事务-->ACID
    事务-->弱隔离级别
    弱隔离级别-->读-提交
    弱隔离级别-->快照级别隔离与可重复读
    读-提交-->两个版本
    两个版本-->脏读
    读-提交-->行级锁
    行级锁-->脏写

    快照级别隔离与可重复读-->读倾斜
    读倾斜-->一致性快照
    一致性快照-->MVCC
    MVCC-->脏读
    一致性快照-->写锁
    写锁-->脏写

    弱隔离级别-->更新丢失
    更新丢失-->原子写操作
    更新丢失-->显式加锁

    弱隔离级别-->写倾斜
    弱隔离级别-->幻读
    写倾斜-->串行化
    幻读-->串行化
    事务-->串行化
    串行化-->严格按照串行顺序执行
    串行化-->两阶段锁定
    串行化-->可串行化的快照隔离
    两阶段锁定-->谓词锁
    两阶段锁定-->索引区间锁
    可串行化的快照隔离-->基于过期的条件做决定 
</div>
```
写倾斜是在快照隔离条件下发生的，只有可串行化级别才可以解决。

可串行化的快照隔离（SSI），事务中的所有读取操作都是基于数据库的一致性快照（快照级别隔离），在快照隔离的基础上，SSI新增加了相关算法来检测写入之间的串行化冲突从而决定中止哪些事务，如下两点：

- 检测是否读取了过期的MVCC对象：当事务**提交**（为什么不是检测到读旧值就立即中止事务呢？1.事务可能是个只读事务。2.之前写入新值的事务在写入之后发生了中止或者还处于未提交状态，因此读取的并非是过期值。）时，数据库会检查是否存在一些当初被（MVCC）忽略的写操作现在已经完成了提交，如果是则必须中止当前事务
- 检测写是否影响了之前的读：但另一个事务尝试修改时，它首先检查索引，从而确定是否最近存在一些读目标数据的其他事务。这个过程类似于在受影响的字段范围上获取写锁，但它并不会阻塞读取，而是直到读事务提交时才进一步通知他们：所读到的数据现在已经发生了变化。

第八章 分布式系统的挑战

```html
<script src="/assets/js/mermaid.min.js"></script>
<div class="mermaid">  
graph LR
    挑战-->不可靠网络
    挑战-->不可靠时钟
    挑战-->真相与谎言
    真相与谎言-->quorum
    真相与谎言-->Fencing令牌
    真相与谎言-->拜占庭故障
    真相与谎言-->理论系统模型与现实
</div>
```

第九章 一致性与共识

可线性化：使多副本对外看起来好像是单一副本，然后所有操作以原子方式运行，就像一个单线程程序操作变量一样。

`可串行化`的快照隔离则不是`线性化`的：按照设计，它可以从一致性快照中读取，以避免读、写之间的竞争。一致性快照的要点在于它里面不包括快照点创建时刻之后的写入数据，因此从快照读取肯定不满足线性化。

因果关系对事件进行了某种排序（根据事件发生的原因-结果依赖关系）。线性化是将所有操作都放在唯一的、全局有序时间线上，而因果性则不同，它为我们提供了一个弱一致性模型：允许存在某些并发事件，所以版本历史是一个包含多个分支与合并的时间线。

<script src="/assets/js/mermaid.min.js"></script>
<div class="mermaid">  
graph LR
	一致性与共识-->可线性化
	一致性与共识-->顺序保证
	一致性与共识-->分布式事务与共识
    
	可线性化-->线性化的依赖条件
	可线性化-->实现线性化系统
	实现线性化系统-->线性化与quorum
	可线性化-->线性化的代价
	线性化的代价-->CAP理论
    
	顺序保证-->顺序与因果关系
	顺序保证-->序列号排序
	顺序保证-->全序关系广播
    
	分布式事务与共识-->原子提交与两阶段提交
	原子提交与两阶段提交-->2PC
	2PC-->协调者
	分布式事务与共识-->支持容错的共识
	支持容错的共识-->全序广播
	支持容错的共识-->主从复制如何选主    
  	支持容错的共识-->共识的局限性
</div>










