---
layout: post
title: ddia
tags: [database]

---

第五章 数据复制

<script src="/assets/js/mermaid.min.js"></script>
<div class="mermaid">    
graph LR
    数据复制-->主从复制
    数据复制-->多主节点复制
    数据复制-->无主节点复制
	主从复制--> B(复制滞后问题)
	B-->C(读自己的写)
	B-->D(单调读)
	B-->E(前缀一致读)
	C-->F(事务)
	D-->F
	E-->F
	多主节点复制-->写冲突
	无主节点复制-->节点失效
	节点失效-->读修复
	节点失效-->反熵
	无主节点复制-->写冲突
	写冲突-->LWW
	写冲突-->Happens-before  
</div>



第六章 数据分区

<script src="/assets/js/mermaid.min.js"></script>
<div class="mermaid">    
graph LR
    数据分区-->分区办法
    数据分区-->二级索引分区
    数据分区-->分区再平衡
    分区办法-->基于关键字区间的分区
    分区办法-->哈希分区
    二级索引分区-->基于文档分区
    二级索引分区-->基于词条分区
    分区再平衡-->动态再平衡
    分区再平衡-->自动与手动再平衡
    动态再平衡-->固定数量分区
    动态再平衡-->动态分区
    动态再平衡-->按节点比例分区
</div>



第七章 事务

<script src="/assets/js/mermaid.min.js"></script>
<div class="mermaid">    
    graph LR
    事务-->ACID
    事务-->弱隔离级别
    弱隔离级别-->读-提交
    弱隔离级别-->快照级别隔离与可重复读
    读-提交-->两个版本
    两个版本-->脏读
    读-提交-->行级锁
    行级锁-->脏写

    快照级别隔离与可重复读-->读倾斜
    读倾斜-->一致性快照
    一致性快照-->MVCC
    MVCC-->脏读
    一致性快照-->写锁
    写锁-->脏写
    
    弱隔离级别-->更新丢失
    更新丢失-->原子写操作
    更新丢失-->显式加锁
    
    弱隔离级别-->写倾斜
    弱隔离级别-->幻读
    写倾斜-->串行化
    幻读-->串行化
    事务-->串行化
    串行化-->严格按照串行顺序执行
    串行化-->两阶段锁定
    串行化-->可串行化的快照隔离
    两阶段锁定-->谓词锁
    两阶段锁定-->索引区间锁
    可串行化的快照隔离-->基于过期的条件做决定 
</div>

写倾斜：是在快照隔离条件下发生的，只有可串行化级别才可以解决。

可串行化的快照隔离（SSI），事务中的所有读取操作都是基于数据库的一致性快照（快照级别隔离），在快照隔离的基础上，SSI新增加了相关算法来检测写入之间的串行化冲突从而决定中止哪些事务，如下两点：

- 检测是否读取了过期的MVCC对象：当事务**提交**（为什么不是检测到读旧值就立即中止事务呢？1.事务可能是个只读事务。2.之前写入新值的事务在写入之后发生了中止或者还处于未提交状态，因此读取的并非是过期值。）时，数据库会检查是否存在一些当初被（MVCC）忽略的写操作现在已经完成了提交，如果是则必须中止当前事务
- 检测写是否影响了之前的读：但另一个事务尝试修改时，它首先检查索引，从而确定是否最近存在一些读目标数据的其他事务。这个过程类似于在受影响的字段范围上获取写锁，但它并不会阻塞读取，而是直到读事务提交时才进一步通知他们：所读到的数据现在已经发生了变化。



第八章 分布式系统的挑战

<script src="/assets/js/mermaid.min.js"></script>
<div class="mermaid">  
graph LR
    挑战-->不可靠网络
    挑战-->不可靠时钟
    挑战-->真相与谎言
    真相与谎言-->quorum
    真相与谎言-->Fencing令牌
    真相与谎言-->拜占庭故障
    真相与谎言-->理论系统模型与现实
</div>



第九章 一致性与共识

以下三段话出自DDIA，但一开始看到的时候我非常疑惑，不知所云，再详细的解释放在最后，需要结合起来看。

可线性化：使多副本对外看起来好像是单一副本，然后所有操作以原子方式运行，就像一个单线程程序操作变量一样。

因果一致性：按因果关系隔离，无因果关系的操作可以并发执行。

因果关系对事件进行了某种排序（根据事件发生的原因-结果依赖关系）。线性化是将所有操作都放在唯一的、全局有序时间线上，而因果性则不同，它为我们提供了一个弱一致性模型：允许存在某些并发事件，所以版本历史是一个包含多个分支与合并的时间线。



<script src="/assets/js/mermaid.min.js"></script>
<div class="mermaid">  
graph LR
	一致性与共识-->可线性化
	一致性与共识-->顺序保证                                                             
    一致性与共识-->分布式事务与共识
    可线性化-->线性化的依赖条件
    可线性化-->实现线性化系统
    实现线性化系统-->线性化与quorum
    可线性化-->线性化的代价
    线性化的代价-->CAP理论


    顺序保证-->顺序与因果关系
    顺序保证-->序列号排序
    顺序保证-->全序关系广播
    全序关系广播-->采用全序关系广播实现线性化存储
    全序关系广播-->采用线性化存储实现全序关系广播
    
    分布式事务与共识-->原子提交与两阶段提交
    原子提交与两阶段提交-->2PC
    2PC-->协调者
    分布式事务与共识-->支持容错的共识
    支持容错的共识-->全序广播
    支持容错的共识-->主从复制如何选主  
    支持容错的共识-->共识的局限性
</div>    



知乎上的一篇文章翻译了[分布式系统中的一致性模型](https://zhuanlan.zhihu.com/p/48782892)。

线性一致性模型提供了这样的保证：

1.对于观察者来说，所有的读和写都在一个单调递增的时间线上串行地向前推进。 

2.所有的读总能返回最近的写操作的值。

顺序一致性放松了对一致性的要求：

1.不要求操作按照真实的时间序发生。

2.不同进程间的操作执行先后顺序也没有强制要求，但必须是原子的。

3.单个进程内的操作顺序必须和编码时的顺序一直。

 因果一致性比同一进程下对每个操作严格排序的一致性*（即顺序一致性）*来的更宽松——属于同一进程但不同因果关系链的操作能以相对的顺序执行*（也就是说按因果关系隔离，无因果关系的操作可以并发执行）*，这能防止许多不直观的行为发生。 

所以对比上面三个一致性的内容我们可以得出更加简明的结论来：线性一致性是从全局出发的，顺序一致性则以进程为单元，因果一致性以进程内具有因果关系的操作为单元，这三个一致性都在自己的单元要求操作顺序和编码时的顺序一致。

还有一个[线性化和串行化的区别](http://www.bailis.org/blog/linearizability-versus-serializability/)。现在我们可以得出如下结论：

线性一致性、顺序一致性、因果一致性都是对单个对象上（ 例如分布式kv系统中的某个kv对 ）的单个操作而言的，这三个一致性保证这些操作如何如何执行。

串行化包含对多个对象执行的多个操作的事务，执行顺序满足事务集合的某个`全序关系`， 对于一个事务的集合S，可串行化是集合中元素(事务)的一个满足全序关系的排列**（满足要求的排列可以存在多个）**。 

但归根到底这两个概念会被拿来比较是因为文章中写的那样， "One of the reasons these definitions are so confusing is that linearizability hails from the distributed systems and concurrent programming communities, and serializability comes from the database community. Today, almost everyone uses *both* distributed systems and databases, which often leads to overloaded terminology (e.g., “consistency,” “atomicity”). "


