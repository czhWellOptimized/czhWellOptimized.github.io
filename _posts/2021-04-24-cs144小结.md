---
layout: post
title: cs144实验
tags: [computer network]

---

此处是cs144实验小结



![image-20210430115241574](../image/image-20210430115241574.png)

## Lab3

![img](https://img2020.cnblogs.com/blog/1608954/202009/1608954-20200914214900717-282982233.png)

ack传的是下一个期待发的报文段吗？还是这一个的？

seq：占 4 字节，序号范围[0，2^32-1]，序号增加到 2^32-1 后，下个序号又回到 0。TCP 是面向字节流的，通过 TCP 传送的字节流中的每个字节都按顺序编号，而报头中的序号字段值则指的是本报文段数据的第一个字节的序号。
ack：占 4 字节，期望收到对方**下个报文段的第一个数据字节的序号**。

看来我的计算机网络学的果然不好。

## 3.1 When should the TCPSender conclude that a segment was lost and send it again?

1.retransmission timeout 会改变，但是_initial_retransmission_timeout不会改变。

2.不管是第一次发还是重传段，只要length大于0，如果发送的时候timer没有跑，就启动重传计时器（第一种）。

3.当所有发出去的都被确认了，就关闭重传计时器

4.当tick被调用，并且重传计时器超时，

（a）重传最早未被确认的段，

（b）如果窗口大小非0:  （**这里要限制这个条件？**重传了以后窗口肯定不是0啊）

​		i.	_consecutive_retransmissions++,这个被用来TCPConnection判断连接是否没有希望了。

​		ii. RTO*=2

（c）启动重传计时器（第二种），这下重传时间变成RTO*2了。

5.收到ackno的时候

（a）设置RTO=initial value

（b）如果还有任何一个没被确认的数据，重启重传计时器（第三种）

（c）设置_consecutive_retransmissions=0

## 3.2 Implementing the TCP sender

1.fill_window:

从ByteStream中读取尽可能多的字节，只要里面有字节可以读，并且窗口空间允许。

调整_next_seqno。

2.ack_received:

移除ackno范围内的outstand段。

fill_window如果新的窗口出现。

如果ackno不合法就返回false。

3.tick:

时间流逝。

如果重传计时器超时的话，重传最小seqno的段。

4.send_empty_segment:

发送一个0长度的段，设置seq为_next_seqno，不需要当作outstanding，也不用被重传。一般用来当作ack。

## 3.3 FAQs and special cases

The receiver told me its window size was zero bytes. Should I just get stuck and never send any data again? 

接受方告诉发送方 window_size=0，发送方在发送的时候按1Byte发送，这叫做“0窗口探测”，以便探测接受方是否又增加了一些窗口空间。而最坏的情况也就是接受方忽略发送方的这个1Byte段，这没什么。



Bug1：ByteStream里面读取数量超过了deque里的数量，导致出错，铁背锅了。Bug2: (b) If the window size is nonzero: i. Keep track of the number of consecutive retransmissions, and increment it because you just retransmitted something. Your TCPConnection will use this information to decide if the connection is hopeless (too many consecutive retransmissions in a row) and needs to be aborted. ii. Double the value of RTO.3 这个窗口限制条件不对啊

Bug3.只剩下一个窗口的情况下，需要传输一个FIN。其实是这样的fill_window会一直加数据，知道窗口满了。

假设_stream 没有eof，且fin没有发送。循环条件是还有窗口。

最终循环结束条件：

1.没到input结束，发数据，一直发数据，直到没窗口或者数据发没了

2.到input结束

​	1._stream eof + fin发送（窗口大小够发数据+fin）ok

​	2._stream eof （窗口大小仅够发数据）ok

​	3._stream里暂时没内容了(暂时没有数据发，但是还没到fin)ok





总是从第一种状态转移到后面两个状态，所以循环条件限定在window_size存在就可以了，然后后面两种情况都要return。



我写的是个锤子的滑动窗口。。。



## Lab4

![image-20210430152927302](../image/image-20210430152927302.png)

The hardest part will be deciding when to fully terminate a TCPConnection and declare it no longer “active.”

两种方式来处理 连接关闭：

![image-20210430154844099](../image/image-20210430154844099.png)

Option A: lingering after both streams end.

Option B: passive close.

![](../image/receiverState.webp)

![](../image/senderState.webp)

![](../image/both.webp)

![三次握手](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA1MTEwNDA1NjY2?x-oss-process=image/format,png)

<!---->	![四次挥手](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy?x-oss-process=image/format,png)

![image-20210510210259496](../image/image-20210510210259496.png)

同时发SYN为什么要接收？

If the inbound stream ends before the TCPConnection has reached EOF on its outbound stream, this variable needs to be set to false???

​    if(!_linger_after_streams_finish || time_since_last_segment_received() >= 10 * _cfg.rt_timeout){

​        if(_sender.stream_in().eof() && _receiver.stream_out().input_ended() && !_sender.bytes_in_flight()){

​            _active=false;

​        }

​    }????为什么第二个条件也要加进去啊？pdf里没有提到啊

裂开了，fsm_active_close最后一部分本来出错了，但是过了一会儿又不出错了。我什么也没改啊。...

syn、fin算长度，但是ack不算长度

ack不用追踪

我是真傻逼，_sender.tick直接写歪来sbbbbbbbbb

```
void TCPConnection::tick(const size_t ms_since_last_tick) { 
    DUMMY_CODE(ms_since_last_tick); 
    _time_since_last_segment_received+=ms_since_last_tick;
    _sender.tick(ms_since_last_tick);   //日你爹啊
    if(_sender.consecutive_retransmissions() > TCPConfig::MAX_RETX_ATTEMPTS){
        unclean_shutdown(true);
    }        
    push_segments_out();    
}
```



可能会发送空的ack的几种情况：第三次握手；第二次挥手；得到的ack是未来的。

recv rst的条件？



可能是recv那里的bool ret，但也不清楚是不是

![image-20210517165058284](../image/image-20210517165058284.png)

